<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Plane Clock</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: #000;
            color: #0f0;
            overflow: hidden;
            height: 100vh;
            position: relative;
        }

        #clock {
            display: none;
        }

        #model-container {
            position: absolute;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
        }

        #controls {
            position: absolute;
            bottom: 0;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            z-index: 100;
            padding: 100px 20px 20px 20px;
            opacity: 0;
            transition: opacity 0.3s;
        }

        body:hover #controls {
            opacity: 0.2;
        }

        #controls:hover {
            opacity: 1;
        }

        button {
            background: transparent;
            color: #0f0;
            border: 2px solid #0f0;
            padding: 15px 25px;
            font-family: 'Courier New', monospace;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            border-radius: 5px;
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.2);
            text-shadow: 0 0 10px rgba(0, 255, 0, 0.2);
            transition: all 0.3s;
        }

        button:hover {
            background: rgba(0, 255, 0, 0.1);
            box-shadow: 0 0 30px rgba(0, 255, 0, 0.4);
            text-shadow: 0 0 15px rgba(0, 255, 0, 0.4);
            transform: scale(1.05);
        }

        button:active {
            transform: scale(0.95);
        }
    </style>
</head>
<body>
    <div id="clock"></div>
    <div id="model-container"></div>
    <div id="controls">
        <button id="btn-737">Test 7:37</button>
        <button id="btn-747">Test 7:47</button>
        <button id="btn-757">Test 7:57</button>
        <button id="btn-reset">Reset</button>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';
        import { FontLoader } from 'three/addons/loaders/FontLoader.js';
        import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';

        const clockElement = document.getElementById('clock');
        const modelContainer = document.getElementById('model-container');

        let scene, camera, renderer, controls, composer;
        let currentModel = null;
        let currentModelPath = null;
        let modelVisible = false;
        let simulatedTime = null;
        let customShader = null;
        let customPass = null;
        let font = null;
        let textMesh = null;

        // Load font
        async function loadFont() {
            return new Promise((resolve, reject) => {
                const loader = new FontLoader();
                loader.load(
                    'VT323_Regular.json',
                    (loadedFont) => {
                        font = loadedFont;
                        console.log('✓ Font loaded successfully');
                        resolve();
                    },
                    undefined,
                    (error) => {
                        console.error('❌ Font loading error:', error);
                        reject(error);
                    }
                );
            });
        }

        // Create or update text mesh
        function updateTextMesh(timeString) {
            if (!font) return;

            // Remove old text mesh
            if (textMesh) {
                camera.remove(textMesh);
                textMesh.geometry.dispose();
                textMesh.material.dispose();
            }

            // Create new text geometry
            // Scale down text for mobile devices
            const isMobile = window.innerWidth <= 768;
            const textSize = isMobile ? 1.0 / 1.6 : 1.0;

            const textGeometry = new TextGeometry(timeString, {
                font: font,
                size: textSize,
                height: 0.2,
                curveSegments: 12,
                bevelEnabled: true,
                bevelThickness: 0.02,
                bevelSize: 0.02,
                bevelOffset: 0,
                bevelSegments: 5
            });

            // Center the text
            textGeometry.computeBoundingBox();
            const textWidth = textGeometry.boundingBox.max.x - textGeometry.boundingBox.min.x;
            textGeometry.translate(-textWidth / 2, 0, 0);

            // Create material and mesh
            const textMaterial = new THREE.MeshStandardMaterial({
                color: 0x00ff00,
                emissive: 0x00ff00,
                emissiveIntensity: 0.3
            });
            textMesh = new THREE.Mesh(textGeometry, textMaterial);

            // Position text in front of camera (fixed in viewport)
            textMesh.position.set(0, -2, -4);

            camera.add(textMesh);
        }

        // Load fragment shader from file
        async function loadShader() {
            try {
                const response = await fetch('fragment.glsl');
                if (!response.ok) {
                    throw new Error(`Failed to load shader: ${response.status} ${response.statusText}`);
                }
                const fragmentShaderCode = await response.text();

                customShader = {
                    uniforms: {
                        'tDiffuse': { value: null },
                        'time': { value: 0.0 }
                    },
                    vertexShader: `
                        varying vec2 vUv;
                        void main() {
                            vUv = uv;
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                        }
                    `,
                    fragmentShader: fragmentShaderCode
                };

                console.log('✓ Shader loaded successfully');
            } catch (error) {
                console.error('❌ Shader loading error:', error);
                throw error;
            }
        }

        // Initialize Three.js
        function initThree() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);

            // Use window dimensions
            const containerWidth = window.innerWidth;
            const containerHeight = window.innerHeight;

            camera = new THREE.PerspectiveCamera(75, containerWidth / containerHeight, 0.1, 1000);
            camera.position.z = 5;
            scene.add(camera); // Add camera to scene so its children (text) are rendered

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(containerWidth, containerHeight);
            renderer.debug.checkShaderErrors = true;
            modelContainer.appendChild(renderer.domElement);

            // Add WebGL error logging
            const gl = renderer.getContext();
            const oldGetShaderInfoLog = gl.getShaderInfoLog.bind(gl);
            gl.getShaderInfoLog = function(shader) {
                const log = oldGetShaderInfoLog(shader);
                if (log && log.length > 0) {
                    console.error('❌ WebGL Shader Error:', log);
                }
                return log;
            };

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(5, 5, 5);
            scene.add(directionalLight);

            // Setup post-processing
            composer = new EffectComposer(renderer);
            const renderPass = new RenderPass(scene, camera);
            composer.addPass(renderPass);

            try {
                customPass = new ShaderPass(customShader);
                customPass.renderToScreen = true;
                composer.addPass(customPass);
                console.log('✓ Shader compiled successfully');
            } catch (error) {
                console.error('❌ Shader compilation error:', error);
                console.error('Check the fragment.glsl file for syntax errors');
            }

            window.addEventListener('resize', onWindowResize);
        }

        function onWindowResize() {
            const containerWidth = window.innerWidth;
            const containerHeight = window.innerHeight;

            camera.aspect = containerWidth / containerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(containerWidth, containerHeight);
            composer.setSize(containerWidth, containerHeight);
        }

        function loadModel(modelPath) {
            if (currentModel) {
                scene.remove(currentModel);
            }

            const loader = new GLTFLoader();
            loader.load(
                modelPath,
                (gltf) => {
                    currentModel = gltf.scene;

                    // Replace all materials with flat white
                    const whiteMaterial = new THREE.MeshStandardMaterial({
                        color: 0xffffff,
                        flatShading: true
                    });

                    currentModel.traverse((child) => {
                        if (child.isMesh) {
                            child.material = whiteMaterial;
                        }
                    });

                    // Center and scale the model
                    const box = new THREE.Box3().setFromObject(currentModel);
                    const center = box.getCenter(new THREE.Vector3());
                    const size = box.getSize(new THREE.Vector3());
                    const maxDim = Math.max(size.x, size.y, size.z);
                    const scale = 3 / maxDim;

                    currentModel.scale.multiplyScalar(scale);
                    currentModel.position.sub(center.multiplyScalar(scale));

                    // Move model up to avoid overlapping with text
                    currentModel.position.y += 1;

                    scene.add(currentModel);
                },
                undefined,
                (error) => {
                    console.error('Error loading model:', error);
                }
            );
        }

        function showModel(modelPath) {
            // Only reload if the model path has changed
            if (currentModelPath !== modelPath) {
                currentModelPath = modelPath;
                loadModel(modelPath);
            }
            modelVisible = true;
        }

        function hideModel() {
            if (modelVisible) {
                modelVisible = false;
                currentModelPath = null;
            }
        }

        function animate() {
            requestAnimationFrame(animate);

            controls.update();

            // Update shader time uniform (loops every 30 seconds)
            const time = (Date.now() * 0.001) % 30;
            customPass.material.uniforms.time.value = time;

            // Rotate the model using cosine (oscillates 180 degrees, seamless 30s loop)
            if (currentModel && modelVisible) {
                currentModel.rotation.y = Math.cos(time * (Math.PI * 2 / 30)) * (Math.PI / 2);
            }

            composer.render();
        }

        function updateClock() {
            let hours24, minutes, seconds;

            if (simulatedTime) {
                hours24 = simulatedTime.hours;
                minutes = String(simulatedTime.minutes).padStart(2, '0');
                seconds = String(simulatedTime.seconds).padStart(2, '0');
            } else {
                // Get time offset from query param (in hours)
                const urlParams = new URLSearchParams(window.location.search);
                const timeOffset = parseFloat(urlParams.get('timeoffset')) || 0;

                const now = new Date();
                now.setHours(now.getHours() + timeOffset);

                hours24 = now.getHours();
                minutes = String(now.getMinutes()).padStart(2, '0');
                seconds = String(now.getSeconds()).padStart(2, '0');
            }

            // Convert to 12-hour format with AM/PM
            const ampm = hours24 >= 12 ? 'PM' : 'AM';
            const hours12 = hours24 % 12 || 12; // Convert 0 to 12, and 13-23 to 1-11

            // Flashing colon (toggles every second)
            const colon = Math.floor(Date.now() / 1000) % 2 === 0 ? ':' : ' ';
            const timeString = `${hours12}${colon}${minutes} ${ampm}`;
            updateTextMesh(timeString);

            // Check for special times (using 24-hour format)
            const hourMinute = `${String(hours24).padStart(2, '0')}:${minutes}`;

            if (hourMinute === '07:47' || hourMinute === '19:47') {
                showModel('boeing_747.glb');
            } else if (hourMinute === '07:37' || hourMinute === '19:37') {
                showModel('boeing_737.glb');
            } else if (hourMinute === '07:57' || hourMinute === '19:57') {
                showModel('boeing_757.glb');
            } else {
                showModel('clock.glb');
            }
        }

        // Button handlers
        document.getElementById('btn-737').addEventListener('click', () => {
            simulatedTime = { hours: 7, minutes: 37, seconds: 0 };
            updateClock();
        });

        document.getElementById('btn-747').addEventListener('click', () => {
            simulatedTime = { hours: 7, minutes: 47, seconds: 0 };
            updateClock();
        });

        document.getElementById('btn-757').addEventListener('click', () => {
            simulatedTime = { hours: 7, minutes: 57, seconds: 0 };
            updateClock();
        });

        document.getElementById('btn-reset').addEventListener('click', () => {
            simulatedTime = null;
            updateClock();
        });

        // Initialize
        async function init() {
            await loadShader();
            await loadFont();
            initThree();
            animate();
            updateClock();
            setInterval(updateClock, 1000);
        }

        init();
    </script>
</body>
</html>
